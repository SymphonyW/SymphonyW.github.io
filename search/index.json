[{"content":" 1 hhhhhhhhhhhhhhh ","date":"2026-01-06T11:10:12+08:00","image":"https://SymphonyW.github.io/p/birthday/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://SymphonyW.github.io/p/birthday/","title":"Birthday"},{"content":"此Blog用于记录学习Golang时的笔记。\nGo学习笔记 第一部分 基本结构 main函数不能有形参和返回值\n1 2 3 4 5 6 7 8 9 10 11 // 程序入口 package main // fmt 常用标准库 import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) return 0 } 变量声明方式、赋值方式 默认0 1 2 3 var a int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a: %T\\n\u0026#34;, a) 赋初值 1 2 3 var b int = 100 fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;type of b: %T\\n\u0026#34;, b) 省去类型名，类似python 1 2 3 var c = 200 fmt.Println(\u0026#34;c =\u0026#34;, c) fmt.Printf(\u0026#34;type of c: %T\\n\u0026#34;, c) 省去var（最常用方法），直接自动匹配 1 2 3 d := 300 fmt.Println(\u0026#34;d =\u0026#34;, d) fmt.Printf(\u0026#34;type of d: %T\\n\u0026#34;, d) 注：此方式不可用于声明全局变量\n常量声明方式、iota的用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // const和iota // const就是定义变量时把var换成const const PI = 3.1415926 // iota初值为0，往下每行自增1，用于给多个常量赋值 const ( BEIJING = 10 * iota SHANGHAI SHENZHEN ) const ( a, b = iota + 1, iota + 2 // iota = 0,a = 1,b = 2 c, d // iota = 1,c = 2,d = 3 e, f // iota = 2,e = 3,f = 4 g, h = iota * 2, iota * 3 // iota = 3,g = 6,h = 9 i, j // iota = 4,i = 8,j = 12 ) 函数、返回值 单返回值函数 go中的函数参数关键字func在前，类型名与返回值皆在后\n1 2 3 4 5 6 7 func foo1(a string, b int) int { fmt.Println(\u0026#34;====foo1====\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;, b=\u0026#34;, b) c := 100 return c } 多返回值函数(1) 多返回值就用括号包起来\n1 2 3 4 5 6 7 func foo2(a string, b int) (int, int) { fmt.Println(\u0026#34;====foo2====\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;, b=\u0026#34;, b) c := 100 return c, c + 10 } 多返回值函数(2) go中的函数参数关键字func在前，类型名与返回值皆在后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func foo3(a string, b int) (r1 int, r2 int) { fmt.Println(\u0026#34;====foo3====\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;, b=\u0026#34;, b) //c := 100 //return c, c + 10 // 或者给有名称的返回值赋值 fmt.Println(\u0026#34;r1 =\u0026#34;, r1, \u0026#34;, r2 =\u0026#34;, r2) // r1,r2属于foo3的形参，初始化默认为0 r1 = 100 r2 = 200 return } 多返回值函数(3) go中的函数参数关键字func在前，类型名与返回值皆在后\n1 2 3 4 5 6 7 8 9 10 11 12 13 func foo4(a string, b int) (r1, r2 int) { fmt.Println(\u0026#34;====foo4====\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;, b =\u0026#34;, b) //c := 100 //return c, c + 10 // 或者给有名称的返回值赋值 r1 = 100 r2 = 200 return } import时init方法调用流程 import匿名及别名导包形式 匿名导包 匿名导包用 _ 表示，可以导入某个包但不使用\n1 2 3 4 5 import _ \u0026#34;fmt\u0026#34; func main() { // 不会报未使用的错 } 别名导包 匿名导包用 . 表示，使用包中的方法时无需指明是哪个包的方法\n1 2 3 4 5 6 import . \u0026#34;fmt\u0026#34; func main() { Println(\u0026#34;hello world\u0026#34;) // fmt.Println(\u0026#34;hello world\u0026#34;) } defer语句 defer是在某个函数要结束时执行的语句，多个defer会用过压栈再出栈的顺序执行. 最终的执行顺序应该是func3 -\u0026gt; func2 -\u0026gt; func1。\n值得注意的是，当defer和return同时存在时，也是先执行return再执行defer。\n1 2 3 4 5 6 7 8 9 10 11 func returnFunc() int { fmt.Println(\u0026#34;this is returnFunc\u0026#34;) return 0 } func deferFunc() { fmt.Println(\u0026#34;this is deferFunc\u0026#34;) } func test() int { defer deferFunc() return returnFunc() } 执行函数test后，输出的结果是：\n1 2 this is returnFunc this is deferFunc 第二部分 数组的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 固定长度数组在函数中的参数类型必须一致，且传参是以复制的形式 func test1(myArray [5]int) { fmt.Printf(\u0026#34;myArray = %v\\n\u0026#34;, myArray) // %v 表示输出：详细信息 } func main() { //定长数组 var myArray [5]int fmt.Println(\u0026#34;myArray =\u0026#34;, myArray) // 默认全0：[0 0 0 0 0] myArray1 := [10]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;myArray1 =\u0026#34;, myArray1) // 未赋值的位置全0：[1 2 3 4 5 0 0 0 0 0] // for循环写法 for i := 0; i \u0026lt; len(myArray); i++ { fmt.Printf(\u0026#34;myArray[%d]=%d\u0026#34;, i, myArray[i]) } fmt.Printf(\u0026#34;\\n\u0026#34;) for index, value := range myArray1 { fmt.Printf(\u0026#34;myArray[%d]=%d\u0026#34;, index, value) } fmt.Printf(\u0026#34;\\n\u0026#34;) // _ 用于表示匿名变量，不会被使用 for _, value := range myArray1 { fmt.Printf(\u0026#34;myArray1[%d]=%d\u0026#34;, value, value) } fmt.Printf(\u0026#34;\\n\u0026#34;) // 变长数组 arr := make([]int, 10) // 默认全0 fmt.Printf(\u0026#34;arr=%v\\n\u0026#34;, arr) // 查看数组的数据类型 fmt.Printf(\u0026#34;myArray types = %T\\n\u0026#34;, myArray) // 数据类型为[5]int fmt.Printf(\u0026#34;myArray1 types = %T\\n\u0026#34;, myArray1) // 数据类型为[10]int\\ test1(myArray) } 输出：\n1 2 3 4 5 6 7 8 9 myArray = [0 0 0 0 0] myArray1 = [1 2 3 4 5 0 0 0 0 0] myArray[0]=0myArray[1]=0myArray[2]=0myArray[3]=0myArray[4]=0 myArray[0]=1myArray[1]=2myArray[2]=3myArray[3]=4myArray[4]=5myArray[5]=0myArray[6]=0myArray[7]=0myArray[8]=0myArray[9]=0 myArray1[1]=1myArray1[2]=2myArray1[3]=3myArray1[4]=4myArray1[5]=5myArray1[0]=0myArray1[0]=0myArray1[0]=0myArray1[0]=0myArray1[0]=0 arr=[0 0 0 0 0 0 0 0 0 0] myArray types = [5]int myArray1 types = [10]int myArray = [0 0 0 0 0] 数组的复制 浅拷贝 1 2 3 4 5 6 7 8 9 10 11 12 arr1 := []int{1, 2, 3, 4} fmt.Printf(\u0026#34;arr1=%v\\n\u0026#34;, arr1) arr2 := arr1 fmt.Printf(\u0026#34;arr2=%v\\n\u0026#34;, arr2) arr1[0] = 999 fmt.Printf(\u0026#34;arr1=%v\\n\u0026#34;, arr1) fmt.Printf(\u0026#34;arr2=%v\\n\u0026#34;, arr2) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr1) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr2) 输出：\n1 2 3 4 5 6 arr1=[1 2 3 4] arr2=[1 2 3 4] arr1=[999 2 3 4] arr2=[999 2 3 4] 0xc0000141e0 0xc0000141e0 深拷贝(copy) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 arr1 := []int{1, 2, 3, 4} fmt.Printf(\u0026#34;arr1=%v\\n\u0026#34;, arr1) arr2 := make([]int, 3) copy(arr2, arr1) fmt.Printf(\u0026#34;arr2=%v\\n\u0026#34;, arr2) arr3 := make([]int, 10) copy(arr3, arr1) fmt.Printf(\u0026#34;arr3=%v\\n\u0026#34;, arr3) arr1[0] = 999 fmt.Printf(\u0026#34;arr1=%v\\n\u0026#34;, arr1) fmt.Printf(\u0026#34;arr2=%v\\n\u0026#34;, arr2) fmt.Printf(\u0026#34;arr3=%v\\n\u0026#34;, arr3) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr1) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr2) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr3) 输出：\n1 2 3 4 5 6 7 8 9 arr1=[1 2 3 4] arr2=[1 2 3] arr3=[1 2 3 4 0 0 0 0 0 0] arr1=[999 2 3 4] arr2=[1 2 3] arr3=[1 2 3 4 0 0 0 0 0 0] 0xc0000141e0 0xc000010150 0xc0000121e0 参数为数组的函数写法及修改的情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func test1(arr1 []int) { arr1 = append(arr1, 10) // 无法得到append后的数组 } func test2(arr1 []int) []int { arr1 = append(arr1, 10) // 通过返回值接收，可以得到append后的数组 return arr1 } func test3(arr1 []int) { arr1[0] = 1 // 可以得到修改后的数组，因此是通过引用传递的参数 } func main() { arr1 := make([]int, 6) test1(arr1) fmt.Printf(\u0026#34;arr1 = %d\\n\u0026#34;, arr1) arr1 = test2(arr1) fmt.Printf(\u0026#34;arr1 = %d\\n\u0026#34;, arr1) test3(arr1) fmt.Printf(\u0026#34;arr1 = %d\\n\u0026#34;, arr1) } 输出：\n1 2 3 arr1 = [0 0 0 0 0 0] arr1 = [0 0 0 0 0 0 10] arr1 = [1 0 0 0 0 0 10] 切片slice的尺寸和容量，以及判空 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { slice1 := []int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;slice1=%v, size=%d, cap=%d\\n\u0026#34;, slice1, len(slice1), cap(slice1)) slice2 := make([]int, 4) fmt.Printf(\u0026#34;slice2=%v, size=%d, cap=%d\\n\u0026#34;, slice2, len(slice2), cap(slice2)) // 默认状态下cap等于size slice3 := make([]int, 3, 5) // make(dataType,size,cap) fmt.Printf(\u0026#34;slice3=%v, size=%d, cap=%d\\n\u0026#34;, slice3, len(slice3), cap(slice3)) // 指定状态下cap大于等于size slice1 = append(slice1, 9) fmt.Printf(\u0026#34;slice1=%v, size=%d, cap=%d\\n\u0026#34;, slice1, len(slice1), cap(slice1)) // cap不足时，cap翻倍，与cpp的vector类似 // 判断一个slice是否为0 var slice []int if slice == nil { fmt.Printf(\u0026#34;slice is nil\\n\u0026#34;) } else { fmt.Printf(\u0026#34;slice is %v\\n\u0026#34;, slice) } } 输出：\n1 2 3 4 5 slice1=[1 2 3 4 5], size=5, cap=5 slice2=[0 0 0 0], size=4, cap=4 slice3=[0 0 0], size=3, cap=5 slice1=[1 2 3 4 5 9], size=6, cap=10 slice is nil 切片截取（设置上下限） 1 2 3 4 5 6 7 8 9 10 func main() { slice1 := []int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;slice1[0:3] = %d\\n\u0026#34;, slice1[0:3]) // 左闭右开的区间 fmt.Printf(\u0026#34;slice1[:3] = %d\\n\u0026#34;, slice1[:3]) // 左边不填默认为0 fmt.Printf(\u0026#34;slice1[1:] = %d\\n\u0026#34;, slice1[1:]) // 右边不填默认为len(slice) slice2 := slice1[0:3] fmt.Printf(\u0026#34;slice2 = %d\\n\u0026#34;, slice2) } 输出：\n1 2 3 4 slice1[0:3] = [1 2 3] slice1[:3] = [1 2 3] slice1[1:] = [2 3 4 5] slice2 = [1 2 3] map的声明、赋值和遍历 第一种声明方式：先声明，再make 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 声明myMap1是一种map类型，key是int，value是string var myMap1 map[int]string if myMap1 == nil { fmt.Printf(\u0026#34;mymap1 is nil\\n\u0026#34;) myMap1 = make(map[int]string, 10) } myMap1[1] = \u0026#34;Beijing\u0026#34; myMap1[2] = \u0026#34;Shanghai\u0026#34; myMap1[3] = \u0026#34;Guangzhou\u0026#34; myMap1[4] = \u0026#34;Shenzhen\u0026#34; myMap1[5] = \u0026#34;Iceland\u0026#34; fmt.Println(myMap1) for k, v := range myMap1 { fmt.Println(k, v) } 输出：\n1 2 3 4 5 6 7 mymap1 is nil map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland] 3 Guangzhou 1 Beijing 2 Shanghai 4 Shenzhen 5 Iceland 第二种声明方式：直接make 1 2 3 4 5 6 7 8 myMap2 := make(map[int]string) myMap2[1] = \u0026#34;Beijing\u0026#34; myMap2[2] = \u0026#34;Shanghai\u0026#34; myMap2[3] = \u0026#34;Guangzhou\u0026#34; myMap2[4] = \u0026#34;Shenzhen\u0026#34; myMap2[5] = \u0026#34;Iceland\u0026#34; fmt.Println(myMap2) 输出：\n1 map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland] 第三种声明方式：声明、赋值同时进行 1 2 3 4 5 6 7 8 9 myMap3 := map[int]string{ 1: \u0026#34;Beijing\u0026#34;, 2: \u0026#34;Shanghai\u0026#34;, 3: \u0026#34;Guangzhou\u0026#34;, 4: \u0026#34;Shenzhen\u0026#34;, 5: \u0026#34;Iceland\u0026#34;, } fmt.Println(myMap3) 输出：\n1 map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland] map的增删改查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 myMap := map[int]string{ 1: \u0026#34;Beijing\u0026#34;, 2: \u0026#34;Shanghai\u0026#34;, 3: \u0026#34;Guangzhou\u0026#34;, 4: \u0026#34;Shenzhen\u0026#34;, 5: \u0026#34;Iceland\u0026#34;, } fmt.Println(myMap) // 添加 myMap[6] = \u0026#34;NewYork\u0026#34; fmt.Println(myMap) // 删除 delete(myMap, 3) fmt.Println(myMap) // 修改 myMap[2] = \u0026#34;Tokyo\u0026#34; fmt.Println(myMap) // 遍历 for key, value := range myMap { fmt.Println(key, value) } 输出\n1 2 3 4 5 6 7 8 9 map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland] map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland 6:NewYork] map[1:Beijing 2:Shanghai 4:Shenzhen 5:Iceland 6:NewYork] map[1:Beijing 2:Tokyo 4:Shenzhen 5:Iceland 6:NewYork] 4 Shenzhen 5 Iceland 6 NewYork 1 Beijing 2 Tokyo 第三部分 struct基本定义与使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 声明一种新的数据类型 type myInt int // 定义一个结构体 type Book struct { title string author string } func main() { var a myInt = 66 fmt.Println(a) var book1 Book book1.title = \u0026#34;Go Programming Language\u0026#34; book1.author = \u0026#34;www.golang.com\u0026#34; fmt.Printf(\u0026#34;%v\\n\u0026#34;, book1) fmt.Printf(\u0026#34;book1.title:%s, book1.author:%s\\n\u0026#34;, book1.title, book1.author) } 输出\n1 2 3 66 {Go Programming Language www.golang.com} book1.title:Go Programming Language, book1.author:www.golang.com 类的表示与封装 值得注意的是，Go与cpp不同，cpp是显式定义类的成员类型(public、private)，而Go是通过首字母是否大写来表示是否是public。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 如果类名首字母大写，表示其他包也能够访问 type Hero struct { // 如果说类的属性首字母大写，表示该属性是对外能够访问的(public)，否则只能在类的内部使用(private) Name string Ad int Level int } // hero Hero表示当前函数绑定在调用这个函数的Hero对象中，其实也就是一个参数，所以最好传指针进去 // 相当于cpp中类里的成员函数 func (hero *Hero) GetName() string { fmt.Println(\u0026#34;Name:\u0026#34;, hero.Name) return hero.Name } func (hero *Hero) Show() { fmt.Println(\u0026#34;Hero:\u0026#34;, hero.Name) fmt.Println(\u0026#34;Ad:\u0026#34;, hero.Ad) fmt.Println(\u0026#34;Level:\u0026#34;, hero.Level) } // func (hero Hero) SetName(newName string) { // //hero 是调用该方法的对象的一个副本(浅拷贝) // hero.Name = newName // } // 最好是使用hero *Hero来绑定 func (hero *Hero) SetName(newName string) { //this 是调用该方法的对象的一个副本(浅拷贝) hero.Name = newName } func main() { // 创建一个对象 hero := Hero{Name: \u0026#34;Spider-Man\u0026#34;, Ad: 5, Level: 1} hero.Show() fmt.Println(hero.GetName()) hero.SetName(\u0026#34;wxz\u0026#34;) fmt.Println(hero.GetName()) } 输出\n1 2 3 4 5 6 7 Hero: Spider-Man Ad: 5 Level: 1 Name: Spider-Man Spider-Man Name: wxz wxz 继承的语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 type Human struct { name string sex string } func (h *Human) Eat() { fmt.Printf(\u0026#34;Human.Eat()...\\n\u0026#34;) } func (h *Human) Walk() { fmt.Printf(\u0026#34;Human.Walk()...\\n\u0026#34;) } // ================================ // 子类 type Superman struct { Human // Superman类继承了Human类的属性和方法 level int } // 重写父类的方法 func (s *Superman) Walk() { fmt.Printf(\u0026#34;Superman.Walk()...\\n\u0026#34;) } //func (s *Superman) Eat() { // fmt.Printf(\u0026#34;Superman.Eat()...\\n\u0026#34;) //} func (s *Superman) Show() { fmt.Println(s.name) fmt.Println(s.sex) fmt.Println(s.level) } func main() { h := Human{\u0026#34;zhang3\u0026#34;, \u0026#34;male\u0026#34;} h.Eat() h.Walk() //s := Superman{Human{\u0026#34;lisi\u0026#34;, \u0026#34;male\u0026#34;}, 5} var s Superman s.name = \u0026#34;lisi\u0026#34; s.sex = \u0026#34;male\u0026#34; s.level = 5 s.Show() // 子类的方法 s.Eat() // 父类的方法 s.Walk() // 子类的方法 } 输出\n1 2 3 4 5 6 7 Human.Eat()... Human.Walk()... lisi male 5 Human.Eat()... Superman.Walk()... 面向对象多态的实现与基本要素 先定义一下接口和具体的类，接口的本质是一个指针。\n1 2 3 4 5 type Animal interface { Sleep() GetColor() string GetType() string } 具体的类必须要重写接口中所有的方法，如果没有重写完全的话，接口的指针就无法指向具体的类。\ncat类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Cat struct { Color string } func (cat *Cat) Sleep() { fmt.Printf(\u0026#34;Cat is sleeping...\\n\u0026#34;) } func (cat *Cat) GetColor() string { return cat.Color } func (cat *Cat) GetType() string { return \u0026#34;Cat\u0026#34; } dog类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Dog struct { Color string } func (dog *Dog) Sleep() { fmt.Printf(\u0026#34;Dog is sleeping...\\n\u0026#34;) } func (dog *Dog) GetColor() string { return dog.Color } func (dog *Dog) GetType() string { return \u0026#34;Dog\u0026#34; } 具体用法\n1 2 3 4 5 6 7 8 9 func main() { // 父类对象指针指向子类指针，调用的方法是子类的方法 var animal Animal animal = \u0026amp;Cat{\u0026#34;red\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;yellow\u0026#34;} animal.Sleep() } 输出：\n1 2 Cat is sleeping... Dog is sleeping... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 注意，这边的Animal接口类本质是一个指针，所有传参时应该穿指针进去 func ShowAnimal(animal Animal) { animal.Sleep() fmt.Println(animal.GetColor()) fmt.Println(animal.GetType()) } func main() { // 可以定义具体的类然后取地址 cat := Cat{\u0026#34;red\u0026#34;} dog := Dog{\u0026#34;yellow\u0026#34;} ShowAnimal(\u0026amp;cat) fmt.Printf(\u0026#34;==============\\n\u0026#34;) ShowAnimal(\u0026amp;dog) fmt.Printf(\u0026#34;==============\\n\u0026#34;) // 也可以直接定义类的指针然后传指针 catP := \u0026amp;Cat{\u0026#34;red\u0026#34;} dogP := \u0026amp;Dog{\u0026#34;yellow\u0026#34;} ShowAnimal(catP) fmt.Printf(\u0026#34;==============\\n\u0026#34;) ShowAnimal(dogP) } 输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Cat is sleeping... red Cat ============== Dog is sleeping... yellow Dog ============== Cat is sleeping... red Cat ============== Dog is sleeping... yellow Dog interface空接口万能类型与类型断言机制 interface空接口 interface{}是万能数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 // interface{}是万能数据类型 func myFunc(arg interface{}) { fmt.Println(\u0026#34;myFunc is called...\u0026#34;) fmt.Println(arg) fmt.Println(\u0026#34;type of arg: \u0026#34;, reflect.TypeOf(arg)) // 或者是 // fmt.Printf(\u0026#34;type of d: %T\\n\u0026#34;, arg) } func main() { myFunc(1) myFunc(\u0026#34;Hello World\u0026#34;) myFunc(true) } 输出：\n1 2 3 4 5 6 7 8 9 myFunc is called... 1 type of arg: int myFunc is called... Hello World type of arg: string myFunc is called... true type of arg: bool 类型断言机制 interface{}提供“类型断言”的机制，用于区分此时引用的底层数据类型到底是什么\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // interface{}是万能数据类型 func myFunc(arg interface{}) { value, ok := arg.(int) if !ok { fmt.Println(\u0026#34;arg is not int type\u0026#34;) } else { fmt.Println(\u0026#34;arg is int type, value is: \u0026#34;, value) } } func main() { myFunc(1) myFunc(\u0026#34;Hello World\u0026#34;) myFunc(true) } 输出：\n1 2 3 arg is int type, value is: 1 arg is not int type arg is not int type ","date":"2026-01-05T21:44:12+08:00","image":"https://SymphonyW.github.io/p/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://SymphonyW.github.io/p/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Golang学习笔记"}]