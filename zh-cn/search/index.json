[{"content":"auto,auto\u0026amp;,auto\u0026amp;\u0026amp; 的作用和区别？ 指针数组、数组指针 首先要先区分好什么是指针数组，什么是数组指针：\n常量指针：指向的值不可修改，不可变的是指向的地址的值。 指针常量：指针的地址不可修改，不可变的是指向的地址。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;iostream\u0026gt; int main() { int num = 1; int num2 = 10000; const int* a = \u0026amp;num; // 常量指针：指向的值不可修改 int* const b = \u0026amp;num; // 指针常量：指针的地址不可修改 std::cout \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; std::endl; // Outputs: 1 std::cout \u0026lt;\u0026lt; *b \u0026lt;\u0026lt; std::endl; // Outputs: 1 // 我们尝试修改a和b所指向的值： // *a = 2; // 报错：不能通过常量指针修改值 *b = 2; // 有效：可以通过指针常量修改值 std::cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; std::endl; // Outputs: 2 // 我们尝试修改a和b所指向的地址： a = \u0026amp;num2; // 有效：可以改变常量指针指向的地址 std::cout \u0026lt;\u0026lt; *a \u0026lt;\u0026lt; std::endl; // Outputs: 10000 // b = \u0026amp;num2; // 报错：不能改变指针常量指向的地址 return 0; } 输出：\n1 2 3 4 1 1 2 10000 auto 值类型推导 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int a = 1; auto va = a; // va 被推导为 int 类型 const int b = a; auto vb = b; // vb 被推导为 int 类型，const 修饰符被忽略 const int* p1 = \u0026amp;a; // 常量指针 auto vp1 = p1; // vp1 被推导为 const int* 类型，指针的 const 修饰符被保留 int* const p2 = \u0026amp;a; // 指针常量 auto vp2 = p2; // vp2 被推导为 int* 类型，指针常量的 const 修饰符被忽略 const char name[] = \u0026#34;example\u0026#34;; auto vname = name; // vname 被推导为 const char* 类型，退化成指针了 推导结果如下图所示，我用的是VS Code中的clangd插件，可以直接看见推到结果，下同。 推导结果 auto\u0026amp; 左值引用推导 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int a = 1; auto\u0026amp; ra = a; // ra 被推导为 int\u0026amp; 类型 const int b = a; auto\u0026amp; rb = b; // rb 被推导为 const int\u0026amp; 类型，保留 const 修饰符 const int* p1 = \u0026amp;a; // 常量指针 auto\u0026amp; rp1 = p1; // rp1 被推导为 const int*\u0026amp; 类型，保留指针的 const 修饰符 int* const p2 = \u0026amp;a; // 指针常量 auto\u0026amp; rp2 = p2; // rp2 被推导为 int* const\u0026amp; 类型，保留指针常量的 const 修饰符 const char name[] = \u0026#34;example\u0026#34;; auto\u0026amp; rname = name; // rname 被推导为 const char (\u0026amp;)[8] 类型，保留数组的 const 修饰符 推导结果如下图所示，我用的是VS Code中的clangd插件，可以直接看见推到结果，下同。 推导结果 auto\u0026amp;\u0026amp; 万能引用推导 1 2 3 4 5 6 7 8 9 10 11 int a = 1; // 左值：变量有名字，有地址； auto\u0026amp;\u0026amp; ua = a; // ua 被推导为 int\u0026amp; 类型（左值引用） const int b = a; auto\u0026amp;\u0026amp; ub = b; // ub 被推导为 const int\u0026amp; 类型（左值引用） // 2是右值：字面值，无名字，无地址； auto\u0026amp;\u0026amp; uc = 2; //被推导为 int 类型（右值引用） const char name[] = \u0026#34;example\u0026#34;; auto\u0026amp;\u0026amp; uname = name; // uname 被推导为 const char (\u0026amp;)[8] 类型（左值引用） 推导结果如下图所示，我用的是VS Code中的clangd插件，可以直接看见推到结果，下同。 推导结果 总结和推导结果解释 auto,auto\u0026amp;amp;,auto\u0026amp;amp;\u0026amp;amp; 的作用 除了auto是值类型以外，auto\u0026amp;和auto\u0026amp;\u0026amp;都是引用，因此也只有auto会拷贝对象。并且在处理const的时候，auto也不同于auto\u0026amp;和auto\u0026amp;\u0026amp;，会忽略掉顶层const保留底层const，而auto\u0026amp;和auto\u0026amp;\u0026amp;会同时保留顶层const和底层const。\nauto,auto\u0026amp;amp;,auto\u0026amp;amp;\u0026amp;amp; 的区别 也就是说，const可以被分为两种：\n顶层const：包括常量指针、基本类型 作用于变量本身，该变量不可修改。 底层const：包括指针常量、引用。 作用于指向或引用的对象，不能通过该变量修改指向的对象。 顶层const和底层const的含义 各种方法是否拷贝对象 是否拷贝我们只需输出一下变量的地址即可得知。\n1 2 3 4 5 6 int a = 1; auto va = a; // va 被推导为 int 类型， 拷贝，内存地址不同 auto\u0026amp; ra = a; // ra 被推导为 int\u0026amp; 类型， 引用，内存地址相同 auto\u0026amp;\u0026amp; ua = a; // ua 被推导为 int\u0026amp; 类型， 引用，内存地址相同 std::cout \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; \u0026amp;va \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; \u0026amp;ra \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; \u0026amp;ua \u0026lt;\u0026lt; std::endl; 输出：\n1 0xcfa3ff768, 0xcfa3ff764, 0xcfa3ff768, 0xcfa3ff768 每次运行输出都会变化，但a、ra和ua的地址是始终相同的。\n","date":"2026-01-23T16:09:18+08:00","image":"https://SymphonyW.github.io/zh-cn/p/autoautoauto-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/background_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_box_smart1_3.png","permalink":"https://SymphonyW.github.io/zh-cn/p/autoautoauto-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB/","title":"auto,auto\u0026,auto\u0026\u0026 的作用和区别？"},{"content":"版本控制（Git）面试题详尽汇总 本指南将面试题分为四个等级：基础概念、常用操作、进阶原理、场景实战与工作流。\n一、 基础概念篇（考察对底层的理解） 1. 什么是版本控制系统（VCS）？为什么需要它？ 回答要点：版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 核心价值：回溯代码、协同工作、错误恢复、责任追踪（Blame）、并行开发。 2. 集中式（CVCS）与分布式（DVCS）版本控制系统的区别？ 集中式（如 SVN）：有一个单一的集中服务器，保存所有文件的修订版本，开发人员连接到这个服务器进行提取和推送。缺点：中央服务器宕机则无法提交代码；断网无法工作。 分布式（如 Git）：客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来（包括历史记录）。优点：绝大多数操作在本地完成，速度快；离线可工作；安全性高（每个人的本地都是备份）。 3. Git 中的三个区域（Three Sections）是什么？ 工作目录 (Working Directory)：你在本地电脑能看到的实际文件。 暂存区 (Staging Area / Index)：一个文件，保存了下次将提交的文件列表信息。 本地仓库 (Local Repository / .git directory)：保存对象数据库和所有提交历史的地方。 补充：还有远程仓库（Remote Repository）。 4. Git 文件的三种状态？ 已修改 (Modified)：修改了文件，但还没保存到数据库中。 已暂存 (Staged)：对一个已修改文件的当前版本做了标记，包含在下次提交中。 已提交 (Committed)：数据已经安全地保存在本地数据库中。 二、 常用操作篇（考察工具熟练度） 5. git pull 和 git fetch 的区别？ git fetch：只从远程下载新分支与数据，不合并到本地当前分支。它更新了 remote/origin/master 指针，但不会改变你的 master 指针。 git pull：相当于 git fetch 紧接着 git merge。它会将远程变动直接合并到当前本地分支。 6. git merge 和 git rebase 的区别？ Merge（合并）：创建一个新的提交（Merge Commit），记录了两个分支合并的历史。保留了完整的历史时序，但会导致提交历史出现繁杂的交叉线。 Rebase（变基）：将当前分支的修改在目标分支的基底上重新应用一遍。优点是提交历史非常整洁，呈线性；缺点是改变了历史提交，严禁在公共分支上使用 rebase。 7. 什么是 git checkout、git switch 和 git restore？ 在旧版本中，checkout 承担了切换分支和恢复文件的双重职责，容易混淆。 git switch：专门用于切换分支。 git restore：专门用于撤销文件的修改。 8. git reset 的三种模式 (\u0026ndash;soft, --mixed, --hard) 有什么区别？ --soft：撤销 commit，代码留在暂存区（Index）。 --mixed（默认）：撤销 commit 和暂存区，代码留在工作目录。 --hard：撤销所有，暂存区和工作目录都会被回退到指定版本。危险操作！ 三、 进阶与原理篇（考察深度） 9. Git 是如何存储数据的？（快照还是差异？） SVN 存储的是文件的差异（Delta-based storage）。 Git 存储的是快照（Snapshot）。如果文件没变，Git 只是存储一个指向之前存储的相同文件的链接。这使得分支切换和历史查询极快。 10. 什么是 git reflog？它和 git log 的区别？ git log：展示当前的提交历史（如果删除了分支或回滚了，相关日志会消失）。 git reflog：记录了本地仓库所有的引用更新历史（包括切换分支、reset、commit 等）。它是最后的“后悔药”，可以用来找回被误删的提交。 11. 什么是 git stash？在什么场景下使用？ 当你正在开发一个功能，突然需要切换到另一个分支修复紧急 Bug，但当前工作还没完成不宜提交时，可以使用 git stash 将当前修改推入堆栈暂时保存。修复完后再用 git stash pop 恢复。 12. 什么是“游离状态的提交”（Detached HEAD）？ 当 HEAD 指向了一个具体的 commit hash 而不是一个分支名时，就处于游离状态。此时提交的代码不属于任何分支，一旦切换分支，这些提交可能会被垃圾回收。解决办法是：立刻在该提交上 git checkout -b \u0026lt;new-branch-name\u0026gt;。 13. Git 中的 cherry-pick 是干什么用的？ 它可以选择某一个特定的提交（commit），并将其应用到当前分支上。常用于从开发分支摘取一个特定的补丁应用到生产分支，而不需要合并整个分支。 四、 场景实战与协作篇 14. 遇到冲突（Merge Conflict）时如何处理？ Git 会提示冲突文件。 打开文件，寻找 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;, =======, \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 标记。 手动决定保留哪些代码。 git add \u0026lt;file\u0026gt; 标记冲突已解决。 git commit 完成合并。 15. 如果发现刚刚的 commit 消息写错了，怎么改？ 使用 git commit --amend。这会打开编辑器让你修改最近一次的提交信息，也可以顺便把漏掉的文件补上去。 16. 如果不小心把敏感信息（如 API Key）提交到了公共仓库，该怎么办？ 仅仅 reset 是不够的，因为历史记录里还有。 需要使用 git filter-branch 或新工具 bfg-repo-cleaner 彻底从历史中抹除该文件。 最重要：立即停用/更换该 API Key。 17. 解释一下你熟悉的工作流（Workflow）。 Git Flow：经典但复杂，有 master, develop, feature, release, hotfix 明确分工。 GitHub Flow：简单，只有 master 和 feature 分支，通过 Pull Request 合并。 Trunk-based Development (主干开发)：频繁向主干合并，适合持续集成（CI/CD）。 18. 如何删除远程分支？ git push origin --delete \u0026lt;branch_name\u0026gt; 五、 趣味/高阶加分题 问：Git 对象有哪几种？ Blob（文件内容）、Tree（目录结构）、Commit（提交信息）、Tag（标签）。 问：.gitignore 没生效是怎么回事？ 文件可能已经被纳入了版本管理（Index 中已存在）。需要先 git rm --cached \u0026lt;file\u0026gt;。 问：什么是 Git Hooks？ 在特定事件发生（如 commit 前、push 前）触发的脚本。常用于代码格式化检查（Pre-commit）。 ","date":"2026-01-22T17:06:02+08:00","image":"https://SymphonyW.github.io/zh-cn/p/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98/background_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://SymphonyW.github.io/zh-cn/p/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98/","title":"版本控制面试常问的问题"},{"content":"Git 版本控制指令完全指南 这份指南旨在帮助你从“会用 Git”进阶到“熟练掌握 Git”。Git 的核心逻辑围绕着四个区域展开：工作区 (Working Directory)、暂存区 (Staging Area/Index)、本地仓库 (Local Repo) 和 远程仓库 (Remote Repo)。\n1. 基础配置 (Configuration) 在开始之前，必须告诉 Git 你是谁。\n指令 作用 git config --global user.name \u0026ldquo;Your Name\u0026rdquo; 设置全局用户名 git config --global user.email \u0026ldquo;email@example.com\u0026rdquo; 设置全局邮箱 git config --list 查看当前所有的配置信息 git config --global core.editor \u0026ldquo;code --wait\u0026rdquo; 将 VS Code 设为默认编辑器（用于编写复杂的提交信息或合并冲突） 2. 初始化与克隆 (Setup \u0026amp; Project Start) 指令 作用 git init 在当前文件夹初始化一个新的 Git 仓库 git clone \u0026lt;url\u0026gt; 下载一个远程仓库到本地 git remote add origin \u0026lt;url\u0026gt; 将本地仓库关联到一个远程仓库（origin 是远程仓库的默认代称） 3. 日常开发“三部曲” (The Basic Workflow) 这是你每天使用次数最多的指令。\n指令 作用 git status 查看状态。显示哪些文件被修改了、哪些在暂存区、哪些未被追踪。 git add \u0026lt;file\u0026gt; 将指定文件添加到暂存区。git add . 代表添加当前目录下所有变更。 git commit -m \u0026ldquo;message\u0026rdquo; 将暂存区的文件提交到本地仓库。-m 后面必须跟随清晰的说明。 git diff 查看工作区与暂存区的代码差异（即你到底改了哪几行）。 git log 查看提交历史。常用参数：\u0026ndash;oneline (精简一行显示), --graph (显示分支图)。 4. 分支管理 (Branching) “熟练”的关键在于对分支的掌控。\n指令 作用 git branch 查看所有本地分支。 git branch \u0026lt;name\u0026gt; 创建一个新分支，但不切换过去。 git checkout \u0026lt;name\u0026gt; 切换到指定分支。 git checkout -b \u0026lt;name\u0026gt; 最常用：创建并立即切换到新分支。 git merge \u0026lt;name\u0026gt; 将指定分支合并到当前分支。 git branch -d \u0026lt;name\u0026gt; 删除已合并的分支。 git rebase \u0026lt;name\u0026gt; 进阶：变基操作。将当前分支的修改在指定分支的基础上重新应用，保持历史线呈线性（面试常考点）。 5. 远程同步 (Remote Sync) 处理本地与 GitHub/GitLab 之间的通信。\n指令 作用 git fetch 从远程拉取最新代码到本地仓库，但不自动合并到你的工作区。最安全。 git pull 从远程拉取并自动合并（相当于 fetch + merge）。 git push origin \u0026lt;branch\u0026gt; 将本地分支的提交推送到远程仓库。 git remote -v 查看远程仓库的详细地址信息。 6. 撤销与“后悔药” (Undo \u0026amp; Correction) 面试官非常看重开发者修复错误的能力。\n指令 作用 git checkout -- \u0026lt;file\u0026gt; 丢弃工作区中某个文件的修改，恢复到最后一次提交的状态。 git reset HEAD \u0026lt;file\u0026gt; 将已提交到暂存区的文件撤回到工作区（Unstage）。 git reset --soft HEAD~1 撤销上一次提交，但保留代码改动。常用于“提交错了，改改再提”。 git reset --hard HEAD~1 危险：彻底撤销上一次提交，所有代码改动都会消失！ git revert \u0026lt;commit-id\u0026gt; 生成一个新的提交来抵消某次提交的改动。这是在公共分支撤销代码最安全的方式。 7. 进阶调试指令 (Power Tools) 指令 作用 git stash 神级指令：将当前未完成的工作“藏”起来。当你写到一半需要紧急修复另一个 Bug 时非常有用。 git stash pop 将“藏”起来的工作拿出来继续写。 git cherry-pick \u0026lt;commit-id\u0026gt; 挑选特定的一个提交，将其应用到当前分支。 git blame \u0026lt;file\u0026gt; 查看文件每一行是谁写的、什么时候写的（“追责”神器）。 git clean -fd 删除项目中所有未被追踪的文件和文件夹。 8. 面试高频问题：合并冲突 (Conflict Resolution) 当两个人在同一个文件的同一行做了修改，Git 会报 CONFLICT。\n处理流程：\n打开报错文件，找到 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;, =======, \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 标记。 手动决定保留哪部分代码。 删除冲突标记并保存文件。 执行 git add \u0026lt;file\u0026gt;。 执行 git commit -m \u0026ldquo;fix conflict\u0026rdquo;。 9. VS Code 深度集成使用指南 (GUI Tips) 在 VS Code 界面操作 Git 时，请注意以下细节：\n界面元素拆解 侧边栏数字：显示当前尚未提交的变更文件数量。 文件列表图标： + (加号)：点击它相当于 git add，将文件移入“暂存的更改”。 - (减号)：取消暂存，回到工作区。 ⟲ (箭头)：丢弃更改（慎用！等同于 checkout --），会把你没保存的代码彻底删掉。 蓝色的“同步更改”按钮：执行的是 git pull 后紧接 git push。如果远程有冲突，此按钮会报错，建议先手动 Pull。 可视化冲突解决 (Merge Editor) 当发生冲突时，VS Code 会提示“在合并编辑器中打开”：\n上方两个窗口：左边是“远程的改动”，右边是“你本地的改动”。 下方窗口：最终合并后的结果。 勾选框：你可以直接勾选想要保留的代码行，VS Code 会自动生成合并后的文件，比手动删 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; 标记快得多。 原子化提交 (Partial Commit) 选中行提交：如果你在一个文件里写了两个功能，只想提交其中一个。在代码行号左侧点击右键，选择“暂存选定的范围”。这能实现比命令行更精细的版本控制。 多仓库管理 (Multi-root Repos) 如你截图中所示，VS Code 支持同时管理多个仓库。请确保在点击顶部的“√ (Commit)”图标前，选中的是正确的仓库分支，避免把博客的改动提交到了公共网页仓。 10. 核心注意事项与最佳实践 善用 .gitignore： 在根目录创建 .gitignore 文件。 必须忽略的东西：编译产生的二进制文件、临时文件夹（如 public/、node_modules/）、敏感信息（.env）。 一旦文件被忽略，VS Code 侧边栏那“几百个变更”就会消失，让界面清爽。 强制推送的禁忌： 在界面上右键点击“Push (Force)”是极度危险的操作。除非你是在修复自己的私人分支，否则严禁覆盖公共 main 分支。 提交前先拉取 (Pull before Commit)： 养成习惯，在开始写代码前先点一下左下角的刷新图标。确保你的代码是基于最新版本编写的，能减少 90% 的合并冲突。 推荐插件：GitLens： 安装后，点击代码行可以看到“是谁在什么时候改了这一行”，这在团队协作（或回溯自己两周前写的 Bug）时非常有帮助。 查看 Timeline 视图： 在 VS Code 文件资源管理器下方有一个 Timeline 栏。它可以让你看到单个文件的详细历史演变，即使你没有在 Git 视图里，也能快速找回之前的代码片段。 11. VS Code 文件状态标识详解 (File Status Indicators) 在 VS Code 的文件资源管理器或 Git 侧边栏中，文件名后面的字母和颜色代表了该文件的当前 Git 状态：\n标识 完整名称 颜色 (默认) 含义 U Untracked 绿色 未追踪。这是一个新创建的文件，Git 还没有开始记录它的历史。 M Modified 黄色/橙色 已修改。该文件在仓库中已存在，但你对它的内容做了改动。 A Added 绿色 已添加。你执行了 git add，该文件已被放入暂存区，等待提交。 D Deleted 红色 已删除。该文件已被删除，Git 记录了这一删除操作。 R Renamed 绿色 重命名。你修改了文件名，Git 自动识别到了这一变动。 C Copied 绿色 已复制。文件被复制了一份。 ! Ignored 灰色 已忽略。该文件匹配了 .gitignore 的规则，Git 不会追踪它。 S Submodule - 子模块。该文件夹是一个嵌套的其他 Git 仓库。 状态组合示例： 文件名显示为红色且带 D：你删除了一个受版本控制的文件。 文件名显示为黄色且带 M：你修改了代码，但还没点那个 + 号（add）。 文件名显示为绿色且带 A：你点了 + 号，这行改动现在躺在暂存区里。 12. VS Code版本控制操作示例 基本操作与界面解释 VS Code界面各部分所代表的意思 提交后 拉取并推送 完成 分支相关操作 创建新分支 输入分支名完成创建 切换分支 ","date":"2026-01-22T15:52:12+08:00","image":"https://SymphonyW.github.io/zh-cn/p/git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%8C%87%E5%8D%97/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://SymphonyW.github.io/zh-cn/p/git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%8C%87%E5%8D%97/","title":"Git版本控制指南"},{"content":"即时通讯系统 系统架构 系统架构图 v0.1 基础server构建 v0.1 构建基础Server 此版本只有如下两个文件：\nserver.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; ) type Server struct { Ip string Port int } // 创建一个server的接口 func NewServer(ip string, port int) *Server { server := \u0026amp;Server{ip, port} return server } func (this *Server) Handle(conn net.Conn) { // ...当前链接的业务 fmt.Println(\u0026#34;链接建立成功\u0026#34;) } // 启动服务器的接口 func (this *Server) Start() { // socket listen，net.Listen用于创建套接字，参数为(network, address string)，返回值为(Listener, error) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, this.Ip, this.Port)) if err != nil { fmt.Println(\u0026#34;net.Listen err:\u0026#34;, err) return } // close listen socket defer fmt.Println(\u0026#34;关闭链接\u0026#34;) defer listener.Close() for { // accept，会返回一个连接Conn，和err conn, err := listener.Accept() if err != nil { fmt.Println(\u0026#34;listener.Accept err:\u0026#34;, err) continue } // do handler go this.Handle(conn) } } main.go 1 2 3 4 5 6 package main func main() { server := NewServer(\u0026#34;127.0.0.1\u0026#34;, 8888) server.Start() } 编译运行：\nLinux系统： 1 2 go build -o server main.go server.go server Windows系统 1 2 go build -o server.exe main.go server.go .\\server.exe 最后运行测试的时候，根据系统输入如下指令进行测试：\nLinux系统可以执行nc 127.0.0.1 8888 Windows系统可以执行curl 127.0.0.1:8888 若得到如下输出，则表示构建成功。 v0.2 用户上线及广播功能 user.go(新增) user类型 1 2 3 4 5 6 type User struct { Name string Addr string C chan string // 与用户通信的管道 conn net.Conn // 用户的网络连接 } 方法 创建一个用户的API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func NewUser(conn net.Conn) *User { userAddr := conn.RemoteAddr().String() // 获取用户的网络地址并转为字符串，作为用户名 user := \u0026amp;User{ Name: userAddr, Addr: userAddr, C: make(chan string), // 创建一个用户消息管道 conn: conn, // 保存用户的网络连接 } // 创建完用户对象后，就启动监听当前 User 的消息管道的 goroutine go user.ListenMessage() return user } 监听当前User的channel的方法，一旦有消息，就发送给对端客户端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 func (this *User) ListenMessage() { for { /* 从 channel C 接收消息字符串 msg 在消息末尾加换行符 转换为字节切片 通过网络连接发送给客户端 */ msg := \u0026lt;-this.C this.conn.Write([]byte(msg + \u0026#34;\\n\u0026#34;)) // 将消息发送给客户端 // 将字符串转换为字节切片（因为 Write() 方法需要接收字节切片） } } server.go server类型：新增OnlineMap和Message属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 type Server struct { Ip string Port int // 在线用户列表 OnlineMap map[string]*User // map[key]value，key是用户名，value是User对象指针 mapLock sync.RWMutex // 保护在线用户列表的锁 // 消息广播的channel Message chan string } // 创建一个server的接口 func NewServer(ip string, port int) *Server { server := \u0026amp;Server{ Ip: ip, Port: port, OnlineMap: make(map[string]*User), Message: make(chan string), } return server } 修改Handler方法 在处理客户端上线的Handler创建并添加⽤用户\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func (this *Server) Handle(conn net.Conn) { // ...当前链接的业务 fmt.Println(\u0026#34;链接建立成功！\u0026#34;) user := NewUser(conn) // 用户上线，将用户加入到OnlineMap中 this.mapLock.Lock() this.OnlineMap[user.Name] = user this.mapLock.Unlock() // 广播当前用户上线消息 this.BroadCast(user, \u0026#34;已上线\\n\u0026#34;) // 当前handler阻塞：若当前handler结束，则所有子go程也都会结束 select {} } 新增广播消息方法 1 2 3 4 5 6 // 广播消息的方法 func (this *Server) BroadCast(user *User, msg string) { sendMsg := \u0026#34;[\u0026#34; + user.Addr + \u0026#34;]\u0026#34; + user.Name + \u0026#34;:\u0026#34; + msg this.Message \u0026lt;- sendMsg } 新增监听广播消息channel方法 1 2 3 4 5 6 7 8 9 10 11 12 13 // 监听Message广播消息channel的goroutine，一旦有消息就发送给全部的在线User func (this *Server) ListenMessager() { for { msg := \u0026lt;-this.Message // 不断地从this.Message中读数据 // 将msg发送给全部的在线User this.mapLock.Lock() for _, cli := range this.OnlineMap { // key:_ value:cli cli.C \u0026lt;- msg } this.mapLock.Unlock() } } 修改Start方法 用一个goroutine单独监听Message\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 启动服务器的接口 func (this *Server) Start() { // socket listen，net.Listen用于创建套接字，参数为(network, address string)，返回值为(Listener, error) listener, err := net.Listen(\u0026#34;tcp\u0026#34;, fmt.Sprintf(\u0026#34;%s:%d\u0026#34;, this.Ip, this.Port)) if err != nil { fmt.Println(\u0026#34;net.Listen err:\u0026#34;, err) return } // close listen socket defer fmt.Println(\u0026#34;关闭连接\u0026#34;) defer listener.Close() //--------------在此修改-------------- // 启动监听Message的goroutine go this.ListenMessager() //------------------------------------ for { // accept，会返回一个连接Conn，和err conn, err := listener.Accept() if err != nil { fmt.Println(\u0026#34;listener.Accept err:\u0026#34;, err) continue } // do handler go this.Handle(conn) } } 测试 测试结果如下图所示，可以实现用户上线消息的广播。 v0.3 用户消息广播功能 此版本只需完善server.go中的handler方法即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func (this *Server) Handle(conn net.Conn) { // ...当前链接的业务 fmt.Println(\u0026#34;链接建立成功！\u0026#34;) user := NewUser(conn) // 用户上线，将用户加入到OnlineMap中 this.mapLock.Lock() this.OnlineMap[user.Name] = user this.mapLock.Unlock() // 广播当前用户上线消息 this.BroadCast(user, \u0026#34;上线了\\n\u0026#34;) //--------------新增部分-------------- // 接收客户端发送的消息：对socket进行基本的read操作 go func() { buf := make([]byte, 4096) for { n, err := conn.Read(buf) // 从当前conn套接字中读取数据到buf中，返回值是读取的字节数n和错误信息err if n == 0 { this.BroadCast(user, \u0026#34;下线了\\n\u0026#34;) return } if err != nil \u0026amp;\u0026amp; err != io.EOF { fmt.Println(\u0026#34;Conn Read err:\u0026#34;, err) return } // 提取用户的消息并去除结尾的\u0026#39;\\n\u0026#39; msg := string(buf[:n-1]) // 将得到的消息进行广播 this.BroadCast(user, msg) } }() //--------------------------------- // 当前handler阻塞：若当前handler结束，则所有子go程也都会结束 select {} } 测试 测试结果如下图所示，可以实现广播用户的信息，以及用户下线消息。 v0.4 用户业务封装 与v0.3的功能相同，主要是将用户上线下线以及发送消息的方法封装到user.go中。\nuser类添加新成员变量server 1 2 3 4 5 6 7 8 type User struct { Name string Addr string C chan string // 与用户通信的管道 conn net.Conn // 用户的网络连接 server *Server // 所属服务器 } 新增Online方法 1 2 3 4 5 6 7 8 9 10 // 用户上线的业务 func (this *User) Online() { // 用户上线，将用户加入到OnlineMap中 this.server.mapLock.Lock() this.server.OnlineMap[this.Name] = this this.server.mapLock.Unlock() // 广播当前用户上线消息 this.server.BroadCast(this, \u0026#34;上线了\\n\u0026#34;) } 新增Offline方法 1 2 3 4 5 6 7 8 9 10 // 用户下线的业务 func (this *User) Offline() { // 用户下线，将用户从OnlineMap中删除 this.server.mapLock.Lock() delete(this.server.OnlineMap, this.Name) this.server.mapLock.Unlock() // 广播当前用户下线消息 this.server.BroadCast(this, \u0026#34;下线了\\n\u0026#34;) } 新增DoMessage方法 1 2 3 4 // 用户处理消息的业务 func (this *User) DoMessage(msg string) { this.server.BroadCast(this, msg) } 替换 需要替换的部分 v0.5 在线用户查询 提供SendMsg向对象客户端发送消息API 1 2 3 4 // 给当前user对应的客户端发送消息 func (this *User) SendMsg(msg string) { this.conn.Write([]byte(msg)) } 在DoMessage方法中，加上对“who”指令的处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 用户处理消息的业务 func (this *User) DoMessage(msg string) { if msg == \u0026#34;who\u0026#34; { // 查询当前在线用户都有哪些 this.server.mapLock.Lock() for _, user := range this.server.OnlineMap { onlineMesg := \u0026#34;[\u0026#34; + user.Addr + \u0026#34;]\u0026#34; + user.Name + \u0026#34;:\u0026#34; + \u0026#34;在线\\n\u0026#34; this.SendMsg(onlineMesg) } this.server.mapLock.Unlock() } else { this.server.BroadCast(this, msg) } } 一个小bug 需要注意的是，前面对用户输入的消息仅去掉了最末尾的\u0026rsquo;\\n\u0026rsquo;，但这是不够的，因为Windows下默认的换行标识符是\u0026rsquo;\\r\\n\u0026rsquo;，因此需要去掉末尾的两个元素。 具体修改位置 另外，不同操作系统的默认换行标识符也是不同的，若下图所示： 不同操作系统下的默认换行标识符 测试 **用户输入\u0026quot;who\u0026quot;即可查看当前在线用户。如此，即可实现查询在线用户的操作 查询示例 v0.6 修改用户名 修改代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 用户处理消息的业务 func (this *User) DoMessage(msg string) { if msg == \u0026#34;who\u0026#34; { // 查询当前在线用户都有哪些 this.server.mapLock.Lock() for _, user := range this.server.OnlineMap { onlineMesg := \u0026#34;[\u0026#34; + user.Addr + \u0026#34;]\u0026#34; + user.Name + \u0026#34;:\u0026#34; + \u0026#34;在线\\n\u0026#34; this.SendMsg(onlineMesg) } this.server.mapLock.Unlock() } else if len(msg) \u0026gt; 7 \u0026amp;\u0026amp; msg[:7] == \u0026#34;rename|\u0026#34; { // 消息格式：rename|张三 // string.Split(msg, \u0026#34;sign\u0026#34;)可以将字符串msg以sign为断点来切分，返回的是一个字符串数组 newName := strings.Split(msg, \u0026#34;|\u0026#34;)[1] // 判断name是否存在 _, ok := this.server.OnlineMap[newName] if ok { this.SendMsg(\u0026#34;当前用户名已被使用!\\n\u0026#34;) } else { this.server.mapLock.Lock() delete(this.server.OnlineMap, this.Name) this.server.OnlineMap[newName] = this this.server.mapLock.Unlock() this.Name = newName this.SendMsg(\u0026#34;您已成功更新用户名:\u0026#34; + this.Name + \u0026#34;!\\n\u0026#34;) } } else { this.server.BroadCast(this, msg) } } 在此处进行修改 测试 测试结果如下，成功实现修改用户名及Online Map操作： ","date":"2026-01-21T15:10:42+08:00","image":"https://SymphonyW.github.io/zh-cn/p/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://SymphonyW.github.io/zh-cn/p/%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%B3%BB%E7%BB%9F/","title":"即时通讯系统"},{"content":"此Blog用于记录学习Golang时的笔记。 视频网址：https://www.bilibili.com/video/BV1gf4y1r79E?spm_id_from=333.788.videopod.episodes\u0026amp;vd_source=a28b0a61baf52e2de1f7120e1c9d88e1 视频作者：刘丹冰\nGo学习笔记 第一部分 基本结构 main函数不能有形参和返回值\n1 2 3 4 5 6 7 8 9 10 11 // 程序入口 package main // fmt 常用标准库 import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello World!\u0026#34;) return 0 } 变量声明方式、赋值方式 默认0 1 2 3 var a int fmt.Println(\u0026#34;a =\u0026#34;, a) fmt.Printf(\u0026#34;type of a: %T\\n\u0026#34;, a) 赋初值 1 2 3 var b int = 100 fmt.Println(\u0026#34;b =\u0026#34;, b) fmt.Printf(\u0026#34;type of b: %T\\n\u0026#34;, b) 省去类型名，类似python 1 2 3 var c = 200 fmt.Println(\u0026#34;c =\u0026#34;, c) fmt.Printf(\u0026#34;type of c: %T\\n\u0026#34;, c) 省去var（最常用方法），直接自动匹配 1 2 3 d := 300 fmt.Println(\u0026#34;d =\u0026#34;, d) fmt.Printf(\u0026#34;type of d: %T\\n\u0026#34;, d) 注：此方式不可用于声明全局变量\n常量声明方式、iota的用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // const和iota // const就是定义变量时把var换成const const PI = 3.1415926 // iota初值为0，往下每行自增1，用于给多个常量赋值 const ( BEIJING = 10 * iota SHANGHAI SHENZHEN ) const ( a, b = iota + 1, iota + 2 // iota = 0,a = 1,b = 2 c, d // iota = 1,c = 2,d = 3 e, f // iota = 2,e = 3,f = 4 g, h = iota * 2, iota * 3 // iota = 3,g = 6,h = 9 i, j // iota = 4,i = 8,j = 12 ) 函数、返回值 单返回值函数 go中的函数参数关键字func在前，类型名与返回值皆在后\n1 2 3 4 5 6 7 func foo1(a string, b int) int { fmt.Println(\u0026#34;====foo1====\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;, b=\u0026#34;, b) c := 100 return c } 多返回值函数(1) 多返回值就用括号包起来\n1 2 3 4 5 6 7 func foo2(a string, b int) (int, int) { fmt.Println(\u0026#34;====foo2====\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;, b=\u0026#34;, b) c := 100 return c, c + 10 } 多返回值函数(2) go中的函数参数关键字func在前，类型名与返回值皆在后\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 func foo3(a string, b int) (r1 int, r2 int) { fmt.Println(\u0026#34;====foo3====\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;, b=\u0026#34;, b) //c := 100 //return c, c + 10 // 或者给有名称的返回值赋值 fmt.Println(\u0026#34;r1 =\u0026#34;, r1, \u0026#34;, r2 =\u0026#34;, r2) // r1,r2属于foo3的形参，初始化默认为0 r1 = 100 r2 = 200 return } 多返回值函数(3) go中的函数参数关键字func在前，类型名与返回值皆在后\n1 2 3 4 5 6 7 8 9 10 11 12 13 func foo4(a string, b int) (r1, r2 int) { fmt.Println(\u0026#34;====foo4====\u0026#34;) fmt.Println(\u0026#34;a =\u0026#34;, a, \u0026#34;, b =\u0026#34;, b) //c := 100 //return c, c + 10 // 或者给有名称的返回值赋值 r1 = 100 r2 = 200 return } import时init方法调用流程 init流程 import匿名及别名导包形式 匿名导包 匿名导包用 _ 表示，可以导入某个包但不使用\n1 2 3 4 5 import _ \u0026#34;fmt\u0026#34; func main() { // 不会报未使用的错 } 别名导包 匿名导包用 . 表示，使用包中的方法时无需指明是哪个包的方法\n1 2 3 4 5 6 import . \u0026#34;fmt\u0026#34; func main() { Println(\u0026#34;hello world\u0026#34;) // fmt.Println(\u0026#34;hello world\u0026#34;) } defer语句 defer是在某个函数要结束时执行的语句，多个defer会用过压栈再出栈的顺序执行. 多条defer语句执行顺序 最终的执行顺序应该是func3 -\u0026gt; func2 -\u0026gt; func1。\n值得注意的是，当defer和return同时存在时，也是先执行return再执行defer。\n1 2 3 4 5 6 7 8 9 10 11 func returnFunc() int { fmt.Println(\u0026#34;this is returnFunc\u0026#34;) return 0 } func deferFunc() { fmt.Println(\u0026#34;this is deferFunc\u0026#34;) } func test() int { defer deferFunc() return returnFunc() } 执行函数test后，输出的结果是：\n1 2 this is returnFunc this is deferFunc 第二部分 数组的定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 固定长度数组在函数中的参数类型必须一致，且传参是以复制的形式 func test1(myArray [5]int) { fmt.Printf(\u0026#34;myArray = %v\\n\u0026#34;, myArray) // %v 表示输出：详细信息 } func main() { //定长数组 var myArray [5]int fmt.Println(\u0026#34;myArray =\u0026#34;, myArray) // 默认全0：[0 0 0 0 0] myArray1 := [10]int{1, 2, 3, 4, 5} fmt.Println(\u0026#34;myArray1 =\u0026#34;, myArray1) // 未赋值的位置全0：[1 2 3 4 5 0 0 0 0 0] // for循环写法 for i := 0; i \u0026lt; len(myArray); i++ { fmt.Printf(\u0026#34;myArray[%d]=%d\u0026#34;, i, myArray[i]) } fmt.Printf(\u0026#34;\\n\u0026#34;) for index, value := range myArray1 { fmt.Printf(\u0026#34;myArray[%d]=%d\u0026#34;, index, value) } fmt.Printf(\u0026#34;\\n\u0026#34;) // _ 用于表示匿名变量，不会被使用 for _, value := range myArray1 { fmt.Printf(\u0026#34;myArray1[%d]=%d\u0026#34;, value, value) } fmt.Printf(\u0026#34;\\n\u0026#34;) // 变长数组 arr := make([]int, 10) // 默认全0 fmt.Printf(\u0026#34;arr=%v\\n\u0026#34;, arr) // 查看数组的数据类型 fmt.Printf(\u0026#34;myArray types = %T\\n\u0026#34;, myArray) // 数据类型为[5]int fmt.Printf(\u0026#34;myArray1 types = %T\\n\u0026#34;, myArray1) // 数据类型为[10]int\\ test1(myArray) } 输出：\n1 2 3 4 5 6 7 8 9 myArray = [0 0 0 0 0] myArray1 = [1 2 3 4 5 0 0 0 0 0] myArray[0]=0myArray[1]=0myArray[2]=0myArray[3]=0myArray[4]=0 myArray[0]=1myArray[1]=2myArray[2]=3myArray[3]=4myArray[4]=5myArray[5]=0myArray[6]=0myArray[7]=0myArray[8]=0myArray[9]=0 myArray1[1]=1myArray1[2]=2myArray1[3]=3myArray1[4]=4myArray1[5]=5myArray1[0]=0myArray1[0]=0myArray1[0]=0myArray1[0]=0myArray1[0]=0 arr=[0 0 0 0 0 0 0 0 0 0] myArray types = [5]int myArray1 types = [10]int myArray = [0 0 0 0 0] 数组的复制 浅拷贝 1 2 3 4 5 6 7 8 9 10 11 12 arr1 := []int{1, 2, 3, 4} fmt.Printf(\u0026#34;arr1=%v\\n\u0026#34;, arr1) arr2 := arr1 fmt.Printf(\u0026#34;arr2=%v\\n\u0026#34;, arr2) arr1[0] = 999 fmt.Printf(\u0026#34;arr1=%v\\n\u0026#34;, arr1) fmt.Printf(\u0026#34;arr2=%v\\n\u0026#34;, arr2) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr1) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr2) 输出：\n1 2 3 4 5 6 arr1=[1 2 3 4] arr2=[1 2 3 4] arr1=[999 2 3 4] arr2=[999 2 3 4] 0xc0000141e0 0xc0000141e0 深拷贝(copy) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 arr1 := []int{1, 2, 3, 4} fmt.Printf(\u0026#34;arr1=%v\\n\u0026#34;, arr1) arr2 := make([]int, 3) copy(arr2, arr1) fmt.Printf(\u0026#34;arr2=%v\\n\u0026#34;, arr2) arr3 := make([]int, 10) copy(arr3, arr1) fmt.Printf(\u0026#34;arr3=%v\\n\u0026#34;, arr3) arr1[0] = 999 fmt.Printf(\u0026#34;arr1=%v\\n\u0026#34;, arr1) fmt.Printf(\u0026#34;arr2=%v\\n\u0026#34;, arr2) fmt.Printf(\u0026#34;arr3=%v\\n\u0026#34;, arr3) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr1) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr2) fmt.Printf(\u0026#34;%p\\n\u0026#34;, arr3) 输出：\n1 2 3 4 5 6 7 8 9 arr1=[1 2 3 4] arr2=[1 2 3] arr3=[1 2 3 4 0 0 0 0 0 0] arr1=[999 2 3 4] arr2=[1 2 3] arr3=[1 2 3 4 0 0 0 0 0 0] 0xc0000141e0 0xc000010150 0xc0000121e0 参数为数组的函数写法及修改的情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func test1(arr1 []int) { arr1 = append(arr1, 10) // 无法得到append后的数组 } func test2(arr1 []int) []int { arr1 = append(arr1, 10) // 通过返回值接收，可以得到append后的数组 return arr1 } func test3(arr1 []int) { arr1[0] = 1 // 可以得到修改后的数组，因此是通过引用传递的参数 } func main() { arr1 := make([]int, 6) test1(arr1) fmt.Printf(\u0026#34;arr1 = %d\\n\u0026#34;, arr1) arr1 = test2(arr1) fmt.Printf(\u0026#34;arr1 = %d\\n\u0026#34;, arr1) test3(arr1) fmt.Printf(\u0026#34;arr1 = %d\\n\u0026#34;, arr1) } 输出：\n1 2 3 arr1 = [0 0 0 0 0 0] arr1 = [0 0 0 0 0 0 10] arr1 = [1 0 0 0 0 0 10] 切片slice的尺寸和容量，以及判空 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 func main() { slice1 := []int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;slice1=%v, size=%d, cap=%d\\n\u0026#34;, slice1, len(slice1), cap(slice1)) slice2 := make([]int, 4) fmt.Printf(\u0026#34;slice2=%v, size=%d, cap=%d\\n\u0026#34;, slice2, len(slice2), cap(slice2)) // 默认状态下cap等于size slice3 := make([]int, 3, 5) // make(dataType,size,cap) fmt.Printf(\u0026#34;slice3=%v, size=%d, cap=%d\\n\u0026#34;, slice3, len(slice3), cap(slice3)) // 指定状态下cap大于等于size slice1 = append(slice1, 9) fmt.Printf(\u0026#34;slice1=%v, size=%d, cap=%d\\n\u0026#34;, slice1, len(slice1), cap(slice1)) // cap不足时，cap翻倍，与cpp的vector类似 // 判断一个slice是否为0 var slice []int if slice == nil { fmt.Printf(\u0026#34;slice is nil\\n\u0026#34;) } else { fmt.Printf(\u0026#34;slice is %v\\n\u0026#34;, slice) } } 输出：\n1 2 3 4 5 slice1=[1 2 3 4 5], size=5, cap=5 slice2=[0 0 0 0], size=4, cap=4 slice3=[0 0 0], size=3, cap=5 slice1=[1 2 3 4 5 9], size=6, cap=10 slice is nil 切片截取（设置上下限） 1 2 3 4 5 6 7 8 9 10 func main() { slice1 := []int{1, 2, 3, 4, 5} fmt.Printf(\u0026#34;slice1[0:3] = %d\\n\u0026#34;, slice1[0:3]) // 左闭右开的区间 fmt.Printf(\u0026#34;slice1[:3] = %d\\n\u0026#34;, slice1[:3]) // 左边不填默认为0 fmt.Printf(\u0026#34;slice1[1:] = %d\\n\u0026#34;, slice1[1:]) // 右边不填默认为len(slice) slice2 := slice1[0:3] fmt.Printf(\u0026#34;slice2 = %d\\n\u0026#34;, slice2) } 输出：\n1 2 3 4 slice1[0:3] = [1 2 3] slice1[:3] = [1 2 3] slice1[1:] = [2 3 4 5] slice2 = [1 2 3] map的声明、赋值和遍历 第一种声明方式：先声明，再make 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 声明myMap1是一种map类型，key是int，value是string var myMap1 map[int]string if myMap1 == nil { fmt.Printf(\u0026#34;mymap1 is nil\\n\u0026#34;) myMap1 = make(map[int]string, 10) } myMap1[1] = \u0026#34;Beijing\u0026#34; myMap1[2] = \u0026#34;Shanghai\u0026#34; myMap1[3] = \u0026#34;Guangzhou\u0026#34; myMap1[4] = \u0026#34;Shenzhen\u0026#34; myMap1[5] = \u0026#34;Iceland\u0026#34; fmt.Println(myMap1) for k, v := range myMap1 { fmt.Println(k, v) } 输出：\n1 2 3 4 5 6 7 mymap1 is nil map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland] 3 Guangzhou 1 Beijing 2 Shanghai 4 Shenzhen 5 Iceland 第二种声明方式：直接make 1 2 3 4 5 6 7 8 myMap2 := make(map[int]string) myMap2[1] = \u0026#34;Beijing\u0026#34; myMap2[2] = \u0026#34;Shanghai\u0026#34; myMap2[3] = \u0026#34;Guangzhou\u0026#34; myMap2[4] = \u0026#34;Shenzhen\u0026#34; myMap2[5] = \u0026#34;Iceland\u0026#34; fmt.Println(myMap2) 输出：\n1 map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland] 第三种声明方式：声明、赋值同时进行 1 2 3 4 5 6 7 8 9 myMap3 := map[int]string{ 1: \u0026#34;Beijing\u0026#34;, 2: \u0026#34;Shanghai\u0026#34;, 3: \u0026#34;Guangzhou\u0026#34;, 4: \u0026#34;Shenzhen\u0026#34;, 5: \u0026#34;Iceland\u0026#34;, } fmt.Println(myMap3) 输出：\n1 map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland] map的增删改查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 myMap := map[int]string{ 1: \u0026#34;Beijing\u0026#34;, 2: \u0026#34;Shanghai\u0026#34;, 3: \u0026#34;Guangzhou\u0026#34;, 4: \u0026#34;Shenzhen\u0026#34;, 5: \u0026#34;Iceland\u0026#34;, } fmt.Println(myMap) // 添加 myMap[6] = \u0026#34;NewYork\u0026#34; fmt.Println(myMap) // 删除 delete(myMap, 3) fmt.Println(myMap) // 修改 myMap[2] = \u0026#34;Tokyo\u0026#34; fmt.Println(myMap) // 遍历 for key, value := range myMap { fmt.Println(key, value) } 输出\n1 2 3 4 5 6 7 8 9 map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland] map[1:Beijing 2:Shanghai 3:Guangzhou 4:Shenzhen 5:Iceland 6:NewYork] map[1:Beijing 2:Shanghai 4:Shenzhen 5:Iceland 6:NewYork] map[1:Beijing 2:Tokyo 4:Shenzhen 5:Iceland 6:NewYork] 4 Shenzhen 5 Iceland 6 NewYork 1 Beijing 2 Tokyo 第三部分 struct基本定义与使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 声明一种新的数据类型 type myInt int // 定义一个结构体 type Book struct { title string author string } func main() { var a myInt = 66 fmt.Println(a) var book1 Book book1.title = \u0026#34;Go Programming Language\u0026#34; book1.author = \u0026#34;www.golang.com\u0026#34; fmt.Printf(\u0026#34;%v\\n\u0026#34;, book1) fmt.Printf(\u0026#34;book1.title:%s, book1.author:%s\\n\u0026#34;, book1.title, book1.author) } 输出\n1 2 3 66 {Go Programming Language www.golang.com} book1.title:Go Programming Language, book1.author:www.golang.com 类的表示与封装 值得注意的是，Go与cpp不同，cpp是显式定义类的成员类型(public、private)，而Go是通过首字母是否大写来表示是否是public。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 如果类名首字母大写，表示其他包也能够访问 type Hero struct { // 如果说类的属性首字母大写，表示该属性是对外能够访问的(public)，否则只能在类的内部使用(private) Name string Ad int Level int } // hero Hero表示当前函数绑定在调用这个函数的Hero对象中，其实也就是一个参数，所以最好传指针进去 // 相当于cpp中类里的成员函数 func (hero *Hero) GetName() string { fmt.Println(\u0026#34;Name:\u0026#34;, hero.Name) return hero.Name } func (hero *Hero) Show() { fmt.Println(\u0026#34;Hero:\u0026#34;, hero.Name) fmt.Println(\u0026#34;Ad:\u0026#34;, hero.Ad) fmt.Println(\u0026#34;Level:\u0026#34;, hero.Level) } // func (hero Hero) SetName(newName string) { // //hero 是调用该方法的对象的一个副本(浅拷贝) // hero.Name = newName // } // 最好是使用hero *Hero来绑定 func (hero *Hero) SetName(newName string) { //this 是调用该方法的对象的一个副本(浅拷贝) hero.Name = newName } func main() { // 创建一个对象 hero := Hero{Name: \u0026#34;Spider-Man\u0026#34;, Ad: 5, Level: 1} hero.Show() fmt.Println(hero.GetName()) hero.SetName(\u0026#34;wxz\u0026#34;) fmt.Println(hero.GetName()) } 输出\n1 2 3 4 5 6 7 Hero: Spider-Man Ad: 5 Level: 1 Name: Spider-Man Spider-Man Name: wxz wxz 继承的语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 type Human struct { name string sex string } func (h *Human) Eat() { fmt.Printf(\u0026#34;Human.Eat()...\\n\u0026#34;) } func (h *Human) Walk() { fmt.Printf(\u0026#34;Human.Walk()...\\n\u0026#34;) } // ================================ // 子类 type Superman struct { Human // Superman类继承了Human类的属性和方法 level int } // 重写父类的方法 func (s *Superman) Walk() { fmt.Printf(\u0026#34;Superman.Walk()...\\n\u0026#34;) } //func (s *Superman) Eat() { // fmt.Printf(\u0026#34;Superman.Eat()...\\n\u0026#34;) //} func (s *Superman) Show() { fmt.Println(s.name) fmt.Println(s.sex) fmt.Println(s.level) } func main() { h := Human{\u0026#34;zhang3\u0026#34;, \u0026#34;male\u0026#34;} h.Eat() h.Walk() //s := Superman{Human{\u0026#34;lisi\u0026#34;, \u0026#34;male\u0026#34;}, 5} var s Superman s.name = \u0026#34;lisi\u0026#34; s.sex = \u0026#34;male\u0026#34; s.level = 5 s.Show() // 子类的方法 s.Eat() // 父类的方法 s.Walk() // 子类的方法 } 输出\n1 2 3 4 5 6 7 Human.Eat()... Human.Walk()... lisi male 5 Human.Eat()... Superman.Walk()... 面向对象多态的实现与基本要素 先定义一下接口和具体的类，接口的本质是一个指针。\n1 2 3 4 5 type Animal interface { Sleep() GetColor() string GetType() string } 具体的类必须要重写接口中所有的方法，如果没有重写完全的话，接口的指针就无法指向具体的类。\ncat类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Cat struct { Color string } func (cat *Cat) Sleep() { fmt.Printf(\u0026#34;Cat is sleeping...\\n\u0026#34;) } func (cat *Cat) GetColor() string { return cat.Color } func (cat *Cat) GetType() string { return \u0026#34;Cat\u0026#34; } dog类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Dog struct { Color string } func (dog *Dog) Sleep() { fmt.Printf(\u0026#34;Dog is sleeping...\\n\u0026#34;) } func (dog *Dog) GetColor() string { return dog.Color } func (dog *Dog) GetType() string { return \u0026#34;Dog\u0026#34; } 具体用法\n1 2 3 4 5 6 7 8 9 func main() { // 父类对象指针指向子类指针，调用的方法是子类的方法 var animal Animal animal = \u0026amp;Cat{\u0026#34;red\u0026#34;} animal.Sleep() animal = \u0026amp;Dog{\u0026#34;yellow\u0026#34;} animal.Sleep() } 输出：\n1 2 Cat is sleeping... Dog is sleeping... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 注意，这边的Animal接口类本质是一个指针，所有传参时应该穿指针进去 func ShowAnimal(animal Animal) { animal.Sleep() fmt.Println(animal.GetColor()) fmt.Println(animal.GetType()) } func main() { // 可以定义具体的类然后取地址 cat := Cat{\u0026#34;red\u0026#34;} dog := Dog{\u0026#34;yellow\u0026#34;} ShowAnimal(\u0026amp;cat) fmt.Printf(\u0026#34;==============\\n\u0026#34;) ShowAnimal(\u0026amp;dog) fmt.Printf(\u0026#34;==============\\n\u0026#34;) // 也可以直接定义类的指针然后传指针 catP := \u0026amp;Cat{\u0026#34;red\u0026#34;} dogP := \u0026amp;Dog{\u0026#34;yellow\u0026#34;} ShowAnimal(catP) fmt.Printf(\u0026#34;==============\\n\u0026#34;) ShowAnimal(dogP) } 输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Cat is sleeping... red Cat ============== Dog is sleeping... yellow Dog ============== Cat is sleeping... red Cat ============== Dog is sleeping... yellow Dog interface空接口万能类型与类型断言机制 interface空接口 interface{}是万能数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 // interface{}是万能数据类型 func myFunc(arg interface{}) { fmt.Println(\u0026#34;myFunc is called...\u0026#34;) fmt.Println(arg) fmt.Println(\u0026#34;type of arg: \u0026#34;, reflect.TypeOf(arg)) // 或者是 // fmt.Printf(\u0026#34;type of d: %T\\n\u0026#34;, arg) } func main() { myFunc(1) myFunc(\u0026#34;Hello World\u0026#34;) myFunc(true) } 输出：\n1 2 3 4 5 6 7 8 9 myFunc is called... 1 type of arg: int myFunc is called... Hello World type of arg: string myFunc is called... true type of arg: bool 类型断言机制 interface{}提供“类型断言”的机制，用于区分此时引用的底层数据类型到底是什么\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // interface{}是万能数据类型 func myFunc(arg interface{}) { value, ok := arg.(int) if !ok { fmt.Println(\u0026#34;arg is not int type\u0026#34;) } else { fmt.Println(\u0026#34;arg is int type, value is: \u0026#34;, value) } } func main() { myFunc(1) myFunc(\u0026#34;Hello World\u0026#34;) myFunc(true) } 输出：\n1 2 3 arg is int type, value is: 1 arg is not int type arg is not int type 变量内置的pair结构详细说明 在 Go 中，一个接口变量（interface variable）在运行时内部可以看作是一个pair：(Type, Value)\nType(动态类型)：这是接口实际持有的具体类型（例如 *Book）。 Value (动态值)：这是持有具体数据的指针或值的副本。 定义接口与结构体 1 2 3 4 5 6 7 8 type Reader interface { ReadBook() } type Writer interface { WriteBook() } type Book struct {} // *Book 实现了 Reader 接口 func (b *Book) ReadBook() { fmt.Println(\u0026#34;Read a book.\u0026#34;) } // *Book 实现了 Writer 接口 func (b *Book) WriteBook() { fmt.Println(\u0026#34;Write a book.\u0026#34;) } 这里 *Book（Book 的指针类型）同时实现了 Reader 和 Writer 两个接口的全部方法。这意味着 *Book 类型的变量既可以赋值给 Reader，也可以赋值给 Writer。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func main() { // b: pair\u0026lt;type:Book, value:book{}地址\u0026gt; b := \u0026amp;Book{\u0026#34;To Live\u0026#34;} // r: pair\u0026lt;type: , value: \u0026gt; var r Reader fmt.Println(reflect.TypeOf(r), r) // r: pair\u0026lt;type:Book, value:book{}地址\u0026gt; r = b fmt.Println(reflect.TypeOf(r), r) r.ReadBook() // w: pair\u0026lt;type: , value: \u0026gt; var w Writer fmt.Println(reflect.TypeOf(w), w) // w: pair\u0026lt;type:Book, value:book{}地址\u0026gt; w = r.(Writer) fmt.Println(reflect.TypeOf(w), w) w.WriteBook() } 输出：\n1 2 3 4 5 6 \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; *main.Book \u0026amp;{To Live} Read a book. \u0026lt;nil\u0026gt; \u0026lt;nil\u0026gt; *main.Book \u0026amp;{To Live} Write a book. 从上面的输出可以看出，接口类在未赋值时的pair为(nil,nil)。我们可以把 r 和 w 想象成两个不同的“窗口”，它们看着同一个“房间”（具体的 Book 对象）：\nb (具体指针):\n指向内存中的 Book{}。 r (Reader 接口):\n动态类型: *Book 动态值: 指向 b 能力: 只能看见 ReadBook() w (Writer 接口):\n(通过 r.(Writer) 转换而来) 动态类型: *Book (和 r 一样！) 动态值: 指向 b (和 r 一样！) 能力: 只能看见 WriteBook() 反射reflect机制用法 反射基本类型 reflect.TypeOf() 用于获取变量的类型 reflect.ValueOf() 用于获取变量的值 1 2 3 4 5 6 7 8 9 10 // interface{}作为万能类型，类似模板 func reflectNum(arg interface{}) { fmt.Println(\u0026#34;type : \u0026#34;, reflect.TypeOf(arg)) fmt.Println(\u0026#34;value : \u0026#34;, reflect.ValueOf(arg)) } func main() { var num float64 = 3.1415926 reflectNum(num) } 输出：\n1 2 type : float64 value : 3.1415926 反射复杂类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 type User struct { Id int Name string Age int } func (u *User) Call() { fmt.Println(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, u) } func (u User) Display() { fmt.Println(\u0026#34;user is displayed ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, u) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) fmt.Println(\u0026#34;inputType : \u0026#34;, inputType) //获取input的value inputValue := reflect.ValueOf(input) fmt.Println(\u0026#34;inputValue : \u0026#34;, inputValue) //通过type获取里面的字段 //1. 获取interface的reflect.Type，通过Type得到NumField，进行遍历 //2. 得到每个field，数据类型 //3. 通过field有一个Interface()方法得到对应的value for i := 0; i \u0026lt; inputType.NumField(); i++ { field := inputType.Field(i) value := inputValue.Field(i).Interface() // 变量名 变量类型：变量的值 fmt.Printf(\u0026#34;%s %s: %v\\n\u0026#34;, field.Name, field.Type, value) } //通过type获取里面的方法，调用 fmt.Println(inputType.NumMethod()) // 这里得到的是1，因为Call方法是绑定在*User类型上的，而本方法中reflect.TypeOf()传的是User类型，所以不会计算Call方法 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { method := inputType.Method(i) fmt.Printf(\u0026#34;%s %s: %v\\n\u0026#34;, method.Name, method.Type, method.Func) } } func main() { user := User{1, \u0026#34;wxz\u0026#34;, 22} DoFiledAndMethod(user) } 输出：\n1 2 3 4 5 6 7 inputType : main.User inputValue : {1 wxz 22} Id int: 1 Name string: wxz Age int: 22 1 Display func(main.User): 0x7ff7b08a24e0 结构体标签 相当于注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type Resume struct { Name string `info:\u0026#34;name\u0026#34; doc:\u0026#34;我的名字\u0026#34;` Sex string `info:\u0026#34;sex\u0026#34;` } func findTag(str interface{}) { //t := reflect.TypeOf(str).Elem() // Elem()表示当前结构体的所有元素，其作用是获取指针指向的元素，或者容器（如 Map、Slice、Array、Chan）里的元素类型。 t := reflect.TypeOf(str) for i := 0; i \u0026lt; t.NumField(); i++ { taginfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagdoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info:\u0026#34;, taginfo, \u0026#34; doc:\u0026#34;, tagdoc) } } func main() { var re Resume re = Resume{\u0026#34;wxz\u0026#34;, \u0026#34;male\u0026#34;} findTag(re) } 输出：\n1 2 info: name doc: 我的名字 info: sex doc: 结构体标签在json中的应用 前置准备（导包，创建结构体）：\n1 2 3 4 5 6 7 8 9 10 11 import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Movie struct { Title string `json:\u0026#34;title\u0026#34;` Year int `json:\u0026#34;year\u0026#34;` Price int `json:\u0026#34;rmb\u0026#34;` Actors []string `json:\u0026#34;actors\u0026#34;` } 编码的过程 结构体\u0026mdash;\u0026gt; json 1 2 3 4 5 6 7 8 9 10 11 12 13 movie := Movie{\u0026#34;喜剧之王\u0026#34;, 2000, 10, []string{\u0026#34;xingye\u0026#34;, \u0026#34;zhangbozhi\u0026#34;}} // 编码的过程 结构体---\u0026gt; json jsonStr, err := json.Marshal(movie) if err != nil { fmt.Println(\u0026#34;json marshal error:\u0026#34;, err) return } // 这边输出的字段的名称就是上面在结构体中写的标签 fmt.Println(\u0026#34;jsonStr =\u0026#34;, string(jsonStr)) // 或者 fmt.Printf(\u0026#34;jsonStr = %s\\n\u0026#34;, string(jsonStr)) 输出如下，可以复制到json在线解析的网站中验证：\n1 jsonStr = {\u0026#34;title\u0026#34;:\u0026#34;喜剧之王\u0026#34;,\u0026#34;year\u0026#34;:2000,\u0026#34;rmb\u0026#34;:10,\u0026#34;actors\u0026#34;:[\u0026#34;xingye\u0026#34;,\u0026#34;zhangbozhi\u0026#34;]} 解码的过程 jsonstr\u0026mdash;\u0026gt; 结构体 1 2 3 4 5 6 7 8 9 //jsonStr = {\u0026#34;title\u0026#34;:\u0026#34;喜剧之王\u0026#34;,\u0026#34;year\u0026#34;:2000,\u0026#34;rmb\u0026#34;:10,\u0026#34;actors\u0026#34;:[\u0026#34;xingye\u0026#34;,\u0026#34;zhangbozhi\u0026#34;]} my_movie := Movie{} err = json.Unmarshal(jsonStr, \u0026amp;my_movie) if err != nil { fmt.Println(\u0026#34;json unmarshal error:\u0026#34;, err) return } fmt.Printf(\u0026#34;%#v\\n\u0026#34;, my_movie) fmt.Printf(\u0026#34;%v\\n\u0026#34;, my_movie) 输出：\n1 2 main.Movie{Title:\u0026#34;喜剧之王\u0026#34;, Year:2000, Price:10, Actors:[]string{\u0026#34;xingye\u0026#34;, \u0026#34;zhangbozhi\u0026#34;}} {喜剧之王 2000 10 [xingye zhangbozhi]} 第四部分 goroutine基本模型和调度设计策略 在go中把协程co-routine做了一些修改，包括内存占用和名字（goroutine）。\nGolang对协程的处理 M:1 M:N 调度图 最大支持GOMAXPROCS个goroutine并行\n调度器的设计策略 WorkStealing机制：没G了去别的队列拿 HandOff机制：某个G阻塞了就再开个M来执行阻塞的G所在队列后面的G 创建goroutine 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 子goroutine func newTask() { i := 0 for { // 死循环 i++ fmt.Printf(\u0026#34;new Goroutine : i = %d\\n\u0026#34;, i) time.Sleep(1 * time.Second) } } // 主goroutine func main() { // go关键字：创建一个go程，去执行newTask() 流程 go newTask() i := 0 for { // 死循环 i++ fmt.Printf(\u0026#34;main Goroutine : i = %d\\n\u0026#34;, i) time.Sleep(1 * time.Second) } } 输出：\n1 2 3 4 5 6 7 8 main Goroutine : i = 1 new Goroutine : i = 1 new Goroutine : i = 2 main Goroutine : i = 2 new Goroutine : i = 3 main Goroutine : i = 3 ... ... 也可以用匿名函数创建goroutine\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 主goroutine func main() { // 用go创建承载一个形参为空，返回值为空的一个函数 go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) // 退出当前goroutine runtime.Goexit() fmt.Println(\u0026#34;B\u0026#34;) }() fmt.Println(\u0026#34;A\u0026#34;) //// 退出当前goroutine //runtime.Goexit() }() // 最后这对括号用于传参 go func(a int, b int) bool { fmt.Println(\u0026#34;a = \u0026#34;, a, \u0026#34;b = \u0026#34;, b) return true }(10, 20) for { time.Sleep(1 * time.Second) } } 输出：\n1 2 3 4 5 B B.defer A A.defer a = 10 b = 20 其中，下面这条语句用于退出当前goroutine\n1 runtime.Goexit() channel的基本定义和使用 无缓冲channel 无缓冲的channel若只有写没有读，则写go程会阻塞；如果只有读没有写，则读go程会阻塞。 无缓冲channel channel的基本定义和使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 定义一个无缓冲区的channel，channel就是一个数据结构，且能够保证goroutine间的同步和互斥 c := make(chan int) go func() { defer fmt.Println(\u0026#34;goroutine结束\u0026#34;) fmt.Println(\u0026#34;goroutine 正在运行...\u0026#34;) c \u0026lt;- 666 // 将666发送给c }() num := \u0026lt;-c // 从c中接收数据，并赋值给num fmt.Println(\u0026#34;num =\u0026#34;, num) fmt.Println(\u0026#34;main goroutine 结束...\u0026#34;) 输出：\n1 2 3 4 goroutine 正在运行... goroutine结束 num = 666 main goroutine 结束... 有缓冲channel 有缓冲的channel只有当缓冲区满且还在写入时，写go程才会阻塞；只有当缓冲区空且还在读取时，读go程才会阻塞。 有缓冲channel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 c := make(chan int, 3) // 带有3个缓冲区的channel fmt.Println(\u0026#34;len(c) =\u0026#34;, len(c), \u0026#34;cap(c) =\u0026#34;, cap(c)) go func() { defer fmt.Println(\u0026#34;子go程结束\u0026#34;) for i := 0; i \u0026lt; 4; i++ { c \u0026lt;- i fmt.Println(\u0026#34;子go程正在运行，发送的元素 =\u0026#34;, i, \u0026#34; len(c) =\u0026#34;, len(c), \u0026#34;, cap(c) =\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 4; i++ { num := \u0026lt;-c // 从c中接收数据，并赋值给num fmt.Println(\u0026#34;num =\u0026#34;, num) } fmt.Println(\u0026#34;main 结束\u0026#34;) 当channel满，若继续写数据，则会阻塞。 当channel空，若继续读数据，也会阻塞。\n输出： 1 2 3 4 5 6 7 8 9 10 11 len(c) = 0 cap(c) = 3 子go程正在运行，发送的元素 = 0 len(c) = 1 , cap(c) = 3 子go程正在运行，发送的元素 = 1 len(c) = 2 , cap(c) = 3 子go程正在运行，发送的元素 = 2 len(c) = 3 , cap(c) = 3 num = 0 num = 1 num = 2 num = 3 main 结束 子go程正在运行，发送的元素 = 3 len(c) = 2 , cap(c) = 3 子go程结束 channel的关闭特点 channel的关闭特点 close关键字可以关闭一个channel，channel关闭后只能读不能写，且向未make的channel（nil channel）收发数据都会被阻塞\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 c := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // close关键字可以关闭一个channel，channel关闭后只能读不能写，且向未make的channel（nil channel）收发数据都会被阻塞 close(c) }() for { // ok 如果为true表示channel没有关闭，如果为false表示channel已经关闭 if data, ok := \u0026lt;-c; ok { // if的条件是 ok fmt.Println(data) } else { break } } fmt.Println(\u0026#34;Main finished...\u0026#34;) 输出：\n1 2 3 4 5 6 0 1 2 3 4 Main finished... channel与range 类似C++中的for(auto i:arr)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 c := make(chan int) go func() { for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i } // close关键字可以关闭一个channel，channel关闭后只能读不能写，且向未make的channel（nil channel）收发数据都会被阻塞 close(c) }() /* for { // ok 如果为true表示channel没有关闭，如果为false表示channel已经关闭 if data, ok := \u0026lt;-c; ok { // if的条件是 ok fmt.Println(data) } else { break } } */ // 上面这段代码可以替换为下面这段代码 // 可以使用range来迭代不断操作channel for data := range c { fmt.Println(data) } fmt.Println(\u0026#34;Main finished...\u0026#34;) 输出相同：\n1 2 3 4 5 6 0 1 2 3 4 Main finished... channel与select 单流程下的一个go只能监控一个channel的状态，通过select可以监控多个channel的状态\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 func fibonacci(c chan int, quit chan int) { x, y := 1, 1 for { select { case c \u0026lt;- x: // 如果c可写，则此case就会进来 x, y = y, x+y case \u0026lt;-quit: // 如果quit可读，则此case就会进来 fmt.Println(\u0026#34;quit\u0026#34;) return } } } func main() { c := make(chan int) quit := make(chan int) // sub go go func() { for i := 0; i \u0026lt; 6; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() // main go，channel传参传的都是引用 fibonacci(c, quit) } 输出：\n1 2 3 4 5 6 7 1 1 2 3 5 8 quit 第五部分 什么是Go Modules？ Go modules是Go语言的依赖解决方案，发布于Go1.11，成长于Go1.12，丰富于Go1.13，正式于Go1.14，推荐在生产上使用。\nGo modules目前集成在Go的工具链中，只要安装了Go，自然而然也就可以使用Go modules了，而Go modules的出现也解决了在Go1.11前的几个常见争议问题：\nGo语言长久以来的依赖管理问题。 “淘汰”现有的GOPATH的使用模式。 同意社区中的其他的依赖管理工具（提供迁移功能）。 GOPATH的弊端 在 GOPATH 的 $GOPATH/src 下进行 .go 文件或源代码的存储，我们可以称其为 GOPATH 的模式，这个模式拥有一些弊端。\nA. 无版本控制概念。 在执行go get的时候，你无法传达任何的版本信息的期望，也就是说你也无法知道自己当前更新的是哪一个版本，也无法通过指定来拉取自己所期望的具体版本。 B.无法同步一致第三方版本号。 在运行 Go 应用程序的时候，你无法保证其它人与你所期望依赖的第三方库是相同的版本，也就是说在项目依赖库的管理上，你无法保证所有人的依赖版本都一致。 C.无法指定当前项目引用的第三方版本号。 没办法处理 v1、v2、v3 等等不同版本的引用问题，因为 GOPATH 模式下的导入路径都是一样的，都是github.com/foo/bar。 Go Modules模式 go mod命令 go mod命令 go mod环境变量 可以通过 go env 命令来进行查看\nGO111MODULE GO111MODULE\nGo语言提供了 GO111MODULE这个环境变量来作为 Go modules 的开关，其允许设置以下参数：\nauto：只要项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.14 中仍然是默认值。 on：启用 Go modules，推荐设置，将会是未来版本中的默认值。 off：禁用 Go modules，不推荐设置。 可以在终端执行：go env -w GO111MODULE=on 来设置。\nGOPROXY 这个环境变量主要是用于设置 Go 模块代理（Go module proxy）,其作用是用于使 Go 在后续拉取模块版本时直接通过镜像站点来快速拉取。\nGOPROXY 的默认值是：https://proxy.golang.org,direct\n实际上 “direct” 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 404 或 410 错误时，Go 自动尝试列表中的下一个，遇见 “direct” 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 “invalid version: unknown revision\u0026hellip;” 的错误。\nGOSUMDB 它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。\nGOSUMDB 的默认值为：sum.golang.org，在国内也是无法访问的，但是 GOSUMDB 可以被 Go 模块代理所代理（详见：Proxying a Checksum Database）。\n因此我们可以通过设置 GOPROXY 来解决，而先前我们所设置的模块代理 goproxy.cn 就能支持代理 sum.golang.org，所以这一个问题在设置 GOPROXY 后，你可以不需要过度关心。\n另外若对 GOSUMDB 的值有自定义需求，其支持如下格式：\n格式 1：\u0026lt;SUMDB_NAME\u0026gt;+\u0026lt;PUBLIC_KEY\u0026gt;。 格式 2：\u0026lt;SUMDB_NAME\u0026gt;+\u0026lt;PUBLIC_KEY\u0026gt; \u0026lt;SUMDB_URL\u0026gt;。 也可以将其设置为“off”，也就是禁止 Go 在后续操作中校验模块版本。\nGONOPROXY/GONOSUMDB/GOPRIVATE 这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都是属于私有模块，都是要进行设置的，否则会拉取失败。\n更细致来讲，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。\n而一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值，所以建议的最佳姿势是直接使用 GOPRIVATE。\n并且它们的值都是一个以英文逗号 “,” 分割的模块路径前缀，也就是可以设置多个，例如：\n1 $ go env -w GOPRIVATE=\u0026#34;git.example.com,github.com/eddycjy/mquote\u0026#34; 设置后，前缀为 git.xxx.com 和 github.com/eddycjy/mquote 的模块都会被认为是私有模块。\n如果不想每次都重新设置，我们也可以利用通配符，例如：\n1 $ go env -w GOPRIVATE=\u0026#34;*.example.com\u0026#34; 这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。\n总结 go modules模式的一些内容 使用Go Modules初始化项目 使用Go Modules初始化项目 改变模块依赖关系 改变模块依赖关系 ","date":"2026-01-21T13:54:12+08:00","image":"https://SymphonyW.github.io/zh-cn/p/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://SymphonyW.github.io/zh-cn/p/golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Golang学习笔记"},{"content":" SCORE: 0 SYSTEM: ONLINE DEBUG PROTOCOL 移动鼠标瞄准 / 点击射击\nSTART DEBUGGING SYSTEM CRASHED Bugs took over the kernel.\nFinal Score: 0\nREBOOT SYSTEM ","date":"2026-01-15T18:51:18+08:00","permalink":"https://SymphonyW.github.io/zh-cn/p/%E6%B6%88%E7%81%ADbug/","title":"消灭bug"},{"content":"Markdown 语法速查表 这是一份集成了最常用 Markdown 语法的演示文件。\n1. 标题 (Headings) 一级标题 (H1) 二级标题 (H2) 三级标题 (H3) 四级标题 (H4) 五级标题 (H5) 六级标题 (H6) 2. 文本样式 (Text Styling) 加粗文本 (Bold) 或 加粗文本 斜体文本 (Italic) 或 斜体文本 加粗并斜体 (Bold and Italic) 删除线文本 (Strikethrough) ==高亮文本== (Highlight, 需编辑器支持) 下划线文本 (Underline, HTML) 这也是 [红色文本]{style=\u0026ldquo;color:red\u0026rdquo;} (部分编辑器如Typora支持)\n3. 列表 (Lists) 无序列表 项目 A 项目 B 子项目 B-1 (使用 Tab 缩进) 子项目 B-2 -以此类推 有序列表 第一步 第二步 第三步 任务列表 (Task Lists) 待办事项 已完成事项 4. 引用 (Blockquotes) 这是一段引用文本。\n这是嵌套的引用文本。\n回到第一层引用。\n5. 代码 (Code) 行内代码 请在终端执行 sudo rm -rf / (开个玩笑，请勿模仿)。\n代码块 使用三个反引号包裹：\n1 2 def hello(): print(\u0026#34;Hello, World!\u0026#34;) 1 2 3 4 5 6 package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Go is great!\u0026#34;) } 6. 链接与图片 (Links \u0026amp; Images) Google - 这是一个超链接。 带标题的链接\n图片替代文本 7. 表格 (Tables) 姓名 年龄 职业 对齐方式 张三 18 工程师 左对齐 李四 24 设计师 居中 王五 30 产品经理 右对齐 8. 数学公式 (LaTeX) 行内公式：质能方程是 $E=mc^2$。\n块级公式： $$ \\sum_{i=1}^{n} i = \\frac{n(n+1)}{2} $$\n9. 扩展功能 (Advanced) 分割线 脚注 这里有一个脚注1。\n键盘按键 请按 Ctrl + C 复制。\n流程图 (Mermaid) (注：需要编辑器支持，如 GitHub/Obsidian/Typora)\n1 2 3 4 5 graph LR A[开始] --\u0026gt; B{是否成功?} B -- 是 --\u0026gt; C[结束] B -- 否 --\u0026gt; D[重试] D --\u0026gt; B 脚注的具体内容写在这里。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2026-01-07T19:28:40+08:00","image":"https://SymphonyW.github.io/zh-cn/p/markdown%E8%AF%AD%E6%B3%95/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://SymphonyW.github.io/zh-cn/p/markdown%E8%AF%AD%E6%B3%95/","title":"Markdown语法"},{"content":" 1 hhhhhhhhhhhhhhh ","date":"2026-01-06T11:10:12+08:00","image":"https://SymphonyW.github.io/zh-cn/p/%E7%94%9F%E6%97%A5/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://SymphonyW.github.io/zh-cn/p/%E7%94%9F%E6%97%A5/","title":"生日"}]